var documenterSearchIndex = {"docs":
[{"location":"#Signed-permutations","page":"Home","title":"Signed permutations","text":"Documentation for SignedPerms.","category":"section"},{"location":"#SignedPerms.SignedPerms","page":"Home","title":"SignedPerms.SignedPerms","text":"A  signed permutation of 1:n is  a permutation of the set -n,…,-1,1,…,n which  preserves the  pairs (-i,i).  It is  represented internally as the images of 1:n. It is printed as a product of signed cycles.\n\nExamples\n\njulia> SPerm([-2,-1,-3])\nSPerm{Int64}: (1,-2)(3,-3)\n\nThe group of signed permutations of 1:n is called the hyperoctaedral group.\n\njulia> W=hyperoctaedral_group(2)\nGroup([(1,-1),(1,2)])\n\njulia> elements(W)\n8-element Vector{SPerm{Int8}}:\n ()\n (1,-1)\n (1,2)\n (1,-2,-1,2)\n (1,2,-1,-2)\n (1,-2)\n (2,-2)\n (1,-1)(2,-2)\n\nA  motivation for my use of signed  permutations is to find if two matrices differ  only by a simultaneous signed permutation of lines and columns. See the example below with SPerm(m,n;dims=(1,2)).\n\nThe type of signed permutations is SPerm{T} where T<:Integer, a  struct with one field,  a Vector{T} which holds  the image of 1:n. Using a T different than Int may possibly save space or time. If T is not  specified we  take it  to be  Int16 since  this is a good compromise between speed and compactness.\n\nSPerms  have methods copy, hash, ==, isless  (total order) so they can be keys in hashes or elements of sets; two SPerms are equal if they move the same points to the same images. For instance,\n\njulia> SPerm([-2,-1,-3])==SPerm([-2,-1,-3,4])\ntrue\n\nSPerms are considered as scalars for broadcasting.\n\nFor more information, look at\n\nSPerm, signs, invpermute, orbit, order, last_moved, cycles, cycletype, Matrix, onmats, sstab_onmats, hyperoctaedral_group, SPerm_onmats.\n\n\n\n\n\n","category":"module"},{"location":"#SignedPerms.SPerm","page":"Home","title":"SignedPerms.SPerm","text":"struct SPerm\n\nAn  SPerm represents a signed permutation of 1:n, that is a permutation of  the  set  -n,…,-1,1,…,n  which  preserves  the  pairs (-i,i). It is implemented  by a struct SPerm which has  one field d, a vector holding the images of 1:n. It is printed as its cycle decomposition.\n\n\n\n\n\n","category":"type"},{"location":"#SignedPerms.SPerm-Tuple{Vararg{Integer}}","page":"Home","title":"SignedPerms.SPerm","text":"SPerm{T}(x::Integer...)where T<:Integer\n\nreturns as a SPerm{T} a signed cycle. For instance SPerm{Int8}(1,-2,-1,2)  and SPerm({Int8}[-2,1]) define  the same signed permutation. If not given {T} is taken to be {Int16}.\n\n\n\n\n\n","category":"method"},{"location":"#SignedPerms.@sperm_str-Tuple{String}","page":"Home","title":"SignedPerms.@sperm_str","text":"@sperm\"...\"\n\nmakes a  SPerm  from  a  string  specifying  signed cycles linke the REPL printing of an SPerm; an example is sperm\"(1,-2)(5,-6,7)(-4,9)\"\n\n\n\n\n\n","category":"macro"},{"location":"#PermGroups.Perms.Perm-Tuple{SPerm}","page":"Home","title":"PermGroups.Perms.Perm","text":"Perm(p::SPerm) returns the underlying Perm of an SPerm\n\n\n\n\n\n","category":"method"},{"location":"#SignedPerms.signs","page":"Home","title":"SignedPerms.signs","text":"signs(p::SPerm) returns the underlying signs of an SPerm\n\n\n\n\n\n","category":"function"},{"location":"#PermGroups.Perms.invpermute-Tuple{AbstractVector, SPerm}","page":"Home","title":"PermGroups.Perms.invpermute","text":"invpermute(l::AbstractVector,p::SPerm)\n\nreturns l invpermuted by p, a vector r such that r[abs(i^p)]=l[i]*sign(i^p).\n\njulia> p=SPerm([-2,-1,-3])\nSPerm{Int64}: (1,-2)(3,-3)\n\njulia> invpermute([20,30,40],p)\n3-element Vector{Int64}:\n -30\n -20\n -40\n\ninvpermute can also act on matrices with a keyword dims. If dims=1 it invpermutes  the lines, if dims=2 the  columns and for dims=(1,2) both. If P=Matrix(p) and iP=Matrix(inv(p)) then invpermute(m,p;dims=1)==iP*m,      invpermute(m,p;dims=2)==m*P      and invpermute(m,p;dims=(1,2))==iP*m*P. Finally, the form invpermute(m,p1,p2)  invpermutes the lines of m by p1 and the columns by p2.\n\n\n\n\n\n","category":"method"},{"location":"#PermGroups.Perms.orbit-Tuple{SPerm, Integer}","page":"Home","title":"PermGroups.Perms.orbit","text":"orbit(p::SPerm,i::Integer) returns the orbit of p on i.\n\n\n\n\n\n","category":"method"},{"location":"#PermGroups.Perms.order-Tuple{SPerm}","page":"Home","title":"PermGroups.Perms.order","text":"order(a::SPerm) is the order of the signed permutation a.\n\n\n\n\n\n","category":"method"},{"location":"#PermGroups.Perms.last_moved-Tuple{SPerm}","page":"Home","title":"PermGroups.Perms.last_moved","text":"last_moved(a::SPerm) is the largest integer moved by a\n\n\n\n\n\n","category":"method"},{"location":"#PermGroups.Perms.cycles-Tuple{SPerm}","page":"Home","title":"PermGroups.Perms.cycles","text":"cycles(p::SPerm) the non-trivial cycles of p.\n\nTwo cycles which differ only by sign are returned once only.\n\njulia> cycles(SPerm(-1,2)*SPerm(3,-3)*SPerm(4,5,-4,-5))\n3-element Vector{Vector{Int16}}:\n [1, -2]\n [3, -3]\n [4, 5, -4, -5]\n\n\n\n\n\n","category":"method"},{"location":"#PermGroups.Perms.cycletype-Tuple{SPerm}","page":"Home","title":"PermGroups.Perms.cycletype","text":"cycletype(p::SPerm,n=last_moved(p)) pair  of  partitions  parameterizing  the  conjugacy  class  of  p in the hyperoctaedral group Bₙ\n\njulia> cycletype(SPerm(1,-1),2)\n2-element Vector{Vector{Int64}}:\n [1]\n [1]\n\n\n\n\n\n","category":"method"},{"location":"#Base.Matrix-Tuple{SPerm}","page":"Home","title":"Base.Matrix","text":"Matrix(p::SPerm,n=last_moved(p))  permutation matrix for p operating on n points.\n\nFor a vector v, we have permutedims(v)*Matrix(p)==invpermute(v,p). Also Diagonal(signs(p))*Matrix(Perm(p))==Matrix(p).\n\njulia> Matrix(SPerm([-2,-1,-3]))\n3×3 Matrix{Int64}:\n  0  -1   0\n -1   0   0\n  0   0  -1\n\n\n\n\n\n","category":"method"},{"location":"#SignedPerms.SPerm-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"SignedPerms.SPerm","text":"SPerm{T}(m::AbstractMatrix)  If  m  is  a  signed  permutation  matrix, returns  the corresponding signed permutation of  type T. If omitted, T is taken to be Int16.\n\njulia> m=[0 -1 0;-1 0 0;0 0 -1]\n3×3 Matrix{Int64}:\n  0  -1   0\n -1   0   0\n  0   0  -1\n\njulia> SPerm(m)\n(1,-2)(3,-3)\n\n\n\n\n\n","category":"method"},{"location":"#SignedPerms.SPerm-Tuple{AbstractVector, AbstractVector}","page":"Home","title":"SignedPerms.SPerm","text":"SPerm{T}(l::AbstractVector,l1::AbstractVector)\n\nreturn  a SPerm{T} p  such that invpermute(l1,p)==l  if such p exists; returns  nothing otherwise.  If not  given {T}  is taken to be {Int16}. Needs the entries of l and l1 to be sortable and have operation -.\n\njulia> p=SPerm([20,30,40],[-40,-20,-30])\n(1,-3,2,-1,3,-2)\n\njulia> invpermute([-40,-20,-30],p)\n3-element Vector{Int64}:\n 20\n 30\n 40\n\n\n\n\n\n","category":"method"},{"location":"#PermGroups.Perms.onmats-Tuple{AbstractMatrix, SPerm}","page":"Home","title":"PermGroups.Perms.onmats","text":"onmats(m::AbstractMatrix,g::SPerm) synonym for invpermute(m,g;dims=(1,2)) or invpermute(m,g,g).\n\n\n\n\n\n","category":"method"},{"location":"#SignedPerms.sstab_onmats","page":"Home","title":"SignedPerms.sstab_onmats","text":"sstab_onmats([G,]M[,l])\n\nif  the argument G  is given (which  should be an  SPermGroup) this is just  a fast implementation of centralizer(G,M,onmats). If G is omitted it  is  taken  to  be  hyperoctaedral_group(size(M,1)).  The program uses sophisticated  algorithms, and can  handle matrices up  to 80×80. If l is given the return group should also centralize l (for the action ^)\n\njulia> n=[-1 -1 -1 -2 2 -2 -3 -3 -3; -1 -1 -1 -3 3 -3 -2 -2 -2; -1 -1 -1 -1 1 -1 -1 -1 -1; -2 -3 -1 -3 1 -2 -1 -3 -2; 2 3 1 1 -2 3 3 2 1; -2 -3 -1 -2 3 -1 -2 -1 -3; -3 -2 -1 -1 3 -2 -2 -3 -1; -3 -2 -1 -3 2 -1 -3 -1 -2; -3 -2 -1 -2 1 -3 -1 -2 -3]\n9×9 Matrix{Int64}:\n -1  -1  -1  -2   2  -2  -3  -3  -3\n -1  -1  -1  -3   3  -3  -2  -2  -2\n -1  -1  -1  -1   1  -1  -1  -1  -1\n -2  -3  -1  -3   1  -2  -1  -3  -2\n  2   3   1   1  -2   3   3   2   1\n -2  -3  -1  -2   3  -1  -2  -1  -3\n -3  -2  -1  -1   3  -2  -2  -3  -1\n -3  -2  -1  -3   2  -1  -3  -1  -2\n -3  -2  -1  -2   1  -3  -1  -2  -3\n\njulia> G=sstab_onmats(n)\nGroup([(1,8)(2,6)(4,9),(1,6)(2,8)(5,-7),(1,-2)(3,-3)(4,-9)(5,7)(6,-8),(1,-6)(2,-8)(3,-3)(4,-4)(5,7)(9,-9),(1,2)(4,9)(5,-7)(6,8),(1,-8)(2,-6)(3,-3)(4,-9)(5,-5)(7,-7)])\n\njulia> length(G)\n8\n\n\n\n\n\n","category":"function"},{"location":"#SignedPerms.SPerm-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"SignedPerms.SPerm","text":"SPerm(M::AbstractMatrix,N::AbstractMatrix;dims)\n\nreturns  a signed  permutation p  such that  invpermute(N,p;dims)==M if such  a p exists,  and nothing otherwise.  If dims=(1,2) then M and N should be symmetric matrices.\n\nThe  case dims=(1,2) routine is useful  to identify two objects which are isomorphic  but with different labelings. It  is used in Chevie to identify Lusztig  Fourier transform  matrices with  standard (classified)  data. The program  uses sophisticated algorithms, and can often handle matrices up to 80×80.\n\njulia> p=sperm\"(1,-1)(2,5,3,-4,-2,-5,-3,4)(7,-9)\";\n\njulia> m=onmats(n,p);\n\njulia> onmats(n,SPerm(m,n;dims=(1,2)))==m\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#SignedPerms.hyperoctaedral_group","page":"Home","title":"SignedPerms.hyperoctaedral_group","text":"hyperoctaedral_group(n) \n\nthe hyperoctaedral group on 1:n\n\njulia> W=hyperoctaedral_group(2)\nGroup([(1,-1),(1,2)])\n\njulia> W(1,2)\nSPerm{Int8}: (1,-2,-1,2)\n\n\n\n\n\n","category":"function"},{"location":"#SignedPerms.SPerm_onmats","page":"Home","title":"SignedPerms.SPerm_onmats","text":"SPerm_onmats(M,N;extra=nothing)\n\nM  and N should be symmetric  matrices. SPerm_onmats returns a signed permutation p such that onmats(N,p)=M if such a permutation exists, and nothing  otherwise. If  in addition  vectors extra=[m,n] are given, the signed permutation p should also satisfy invpermute(n,p)==m.\n\nEfficient version of transporting_elt(hyperoctaedral_group(size(M,1)),M,N,onmats)\n\n\n\n\n\n","category":"function"}]
}
